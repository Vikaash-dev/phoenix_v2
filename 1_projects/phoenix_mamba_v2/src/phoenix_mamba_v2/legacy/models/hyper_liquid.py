"""
Hyper-Liquid Layer.
Liquid Time-Constant (LTC) layer with dynamic tau generated by a Hypernetwork.

Source: Consolidated from jules_session_7226522193343951134
"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers


class SpectralNormalization(layers.Wrapper):
    """Spectral Normalization for Hypernetwork stability."""
    
    def __init__(self, layer, iteration=1, **kwargs):
        super(SpectralNormalization, self).__init__(layer, **kwargs)
        self.iteration = iteration

    def build(self, input_shape):
        self.layer.build(input_shape)
        if hasattr(self.layer, 'kernel'):
            self.w = self.layer.kernel
            self.w_shape = self.w.shape.as_list()
            self.u = self.add_weight(
                shape=(1, self.w_shape[-1]),
                initializer=tf.initializers.TruncatedNormal(stddev=0.02),
                trainable=False,
                name='sn_u'
            )
        super(SpectralNormalization, self).build(input_shape)

    def call(self, inputs):
        self._update_weights()
        return self.layer(inputs)

    def _update_weights(self):
        w_reshaped = tf.reshape(self.w, [-1, self.w_shape[-1]])
        u_hat = self.u
        
        for _ in range(self.iteration):
            v_ = tf.matmul(u_hat, w_reshaped, transpose_b=True)
            v_hat = tf.nn.l2_normalize(v_)
            u_ = tf.matmul(v_hat, w_reshaped)
            u_hat = tf.nn.l2_normalize(u_)
        
        sigma = tf.matmul(tf.matmul(v_hat, w_reshaped), u_hat, transpose_b=True)
        self.u.assign(u_hat)
        self.layer.kernel.assign(self.w / sigma)


class HyperLiquidConv2D(layers.Layer):
    """
    Hyper-Liquid Convolutional Layer.
    Hypernetwork generates dynamic time-constants per sample.
    """
    
    def __init__(
        self,
        filters,
        kernel_size=3,
        strides=1,
        time_step=0.1,
        unfold_steps=3,
        **kwargs
    ):
        super(HyperLiquidConv2D, self).__init__(**kwargs)
        self.filters = filters
        self.kernel_size = kernel_size
        self.strides = strides
        self.time_step = time_step
        self.unfold_steps = unfold_steps
        
    def build(self, input_shape):
        # Hyper-Controller: predicts tau from input
        self.hyper_pool = layers.GlobalAveragePooling2D()
        self.hyper_dense1 = SpectralNormalization(
            layers.Dense(16, activation='relu')
        )
        self.hyper_dense2 = layers.Dense(self.filters, activation='sigmoid')
        
        self.input_conv = layers.Conv2D(
            filters=self.filters,
            kernel_size=self.kernel_size,
            strides=self.strides,
            padding='same'
        )
        
        self.recurrent_conv = layers.Conv2D(
            filters=self.filters,
            kernel_size=self.kernel_size,
            strides=1,
            padding='same'
        )
        
        self.bias = self.add_weight(
            name='bias',
            shape=(self.filters,),
            initializer='zeros',
            trainable=True
        )
        
        super(HyperLiquidConv2D, self).build(input_shape)

    def call(self, inputs):
        # Generate Dynamic Tau
        context = self.hyper_pool(inputs)
        tau_raw = self.hyper_dense2(self.hyper_dense1(context))
        tau = tau_raw + 0.1  # Scale to [0.1, 1.1]
        tau = tf.reshape(tau, (-1, 1, 1, self.filters))
        
        # Synaptic Input
        synaptic_input = self.input_conv(inputs)
        
        # ODE Solver with Dynamic Tau
        h = tf.zeros_like(synaptic_input)
        
        for _ in range(self.unfold_steps):
            leakage = -(h - self.bias) / tau
            recurrent_input = self.recurrent_conv(h)
            nonlinear_drive = tf.nn.tanh(synaptic_input + recurrent_input)
            dh_dt = leakage + nonlinear_drive
            h = h + self.time_step * dh_dt
            
        return h

    def get_config(self):
        config = super().get_config()
        config.update({
            'filters': self.filters,
            'kernel_size': self.kernel_size,
            'strides': self.strides,
            'time_step': self.time_step,
            'unfold_steps': self.unfold_steps,
        })
        return config


if __name__ == "__main__":
    layer = HyperLiquidConv2D(32)
    x = tf.random.normal((4, 64, 64, 16))
    y = layer(x)
    print("Input:", x.shape, "Output:", y.shape)
